---
layout: post
author: ainochi-kor
title: React/04. Using the Effect Hook
---


> Hook은 React 16.8에 새로 추가된 기능이다. Hook은 class를 작성하지 않고도 state와 다른 React의 기능들을 사용할 수 있게 해준다.


Effect Hook을 사용하면 함수 컴포넌트에서 side effect를 수행할 수 있다.

``` js
import React, { useState, useEffect } from 'react';

function Example() {
  const [count, setCount] = useState(0);

  // componentDidMount, componentDidUpdate와 같은 방식으로
  useEffect(() => {
    // 브라우저 API를 이용하여 문서 타이틀을 업데이트 한다.
    document.title = `Yout clicked ${count} times`;
  });

  return (
    <div> 
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>
        Click me
      </button>
    </div>
  );
}
```
위의 코드는 이전 페이지의 카운터 예시를 바탕으로 하지만, 문서의 타이틀을 클릭 횟수가 포함된 문장으로 표현할 수 있도록 기능을 더했다.  
  
데이터 가져오기, 구독(subscription) 설정하기, 수동으로 리액트 컴포넌트의 DOM을 수정하는 것까지 이 모든 것이 side effect이다.  
이런 기능들(operations)을 side effect(혹은 effect)라 부른 것이 익숙하지 않을 수 있지만, 아마도 이전에 만들었던 컴포넌트에서 위의 기능들을 구현해보았을 것이다.

> ### 팁
> 리액트의 class 생명주기 메서드에 친숙하다면, useEffect Hook을 componentDidMount와 componentDidUpdate, componentWillUnmount가 합쳐진 것으로 생각해도 좋다.

---

## 정리(Clean-up)을 이용하지 않는 Effects

**리액트가 DOM을 업데이트 한 뒤 추가로 코드를 실행해야 하는 경우가 있다.** 네트워크 리퀘스트, DOM 수동 조작, 로깅 등은 정리(clean-up)가 필요 없는 경우들이다. 이러한 예들은 실행 이후 신경 쓸 것이 없기 때문이다. class와 hook이 이러한 side effects를 어떻게 구현하지는 비교해보자.


### Class를 사용하는 예시

리액트의 class 컴포넌트에서 render 메서드 그 자체는 side effect를 발생시키지 않는다. 이 때는 아직 이른 시기로서 이러한 effect를 수행하는 것은 리액트가 DOM을 업데이트하고 난 이후이다.  
  
리액트 class에서 side effect를 componentDidMount와 componentDidUpdate에 두는 것이 바로 이 때문이다.  
  
[리액트가 DOM을 바꾸고 난 뒤 문서 타이틀을 업데이트하는 리액트 counter 클래스 컴포넌트]

``` js
class Example extends React.Component {
  constructor(props) {
    super(props);
    this.state = (
      count : 0
    );
  }

  componentDidMount() {
    document.title = `You clicked ${this.state.count} times`;
  }

  componentDidUpdate() {
    document.title = `You clicked ${this.state.count} times`;
  }

  render() {
    return (
      <div>
        <p>You clicked {this.state.count} times</p>
        <button onClick={() => this.setState({ count: this.state.count + 1})}>
          Click me
        </button>
      </div>
    );
  }
}
```

위 코드에서 **class 안의 두 개의 생명주기 메서드에 같은 코드가 중복되는 것에 주의하자.**  
  
이는 컴포넌트가 이제 막 마운트된 단계인지 아니면 업데이트 되는 것인지에 상관없이 같은 side effect를 수행해야 하기 때문이다. 개념적으로 렌더링 이후에는 항상 같은 코드가 수행되기를 바라는 것이다. 하지만 리액트 클래스 컴포넌트는 그러한 메서드를 가지고 있지 않다. 함수를 별개의 메서드로 뽑아낸다고 해도 여전히 두 장소에서 함수를 불러내야 한다.

이제 useEffect Hook에서 같은 기능을 어떻게 구현하는지 보자.

### Hook을 이용하는 예시

``` js
import React, {useState, useEffect} from 'react';

function Example() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    document.title = `You clicked ${count} times`;
  });

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>
        Click me
      </button>
    </div>
  );
}
```

#### useEffect가 하는 일은 무엇일까요?
useEffect Hook을 이용하여 우리는 리액트에게 컴포넌트가 렌더링 이후에 어떤 일을 수행해야 하는 지를 말한다. 리액트는 우리가 넘긴 함수를 기억했다가(이 함수를 'effect'라고 부른다.) DOM 업데이트를 수행한 이후에 불러낼 것이다. 위의 경우에도 effect를 통해 문서 타이틀을 지정하지만, 이 외에도 데이터를 가져오거나 다른 명령형(imperative) API를 불러내는 일도 할 수 있다.