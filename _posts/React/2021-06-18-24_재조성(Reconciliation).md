---
layout: post
author: ainochi-kor
title: React/24. 재조성(Reconciliation)
---

React는 선언적 API를 제공하기 때문에 갱신이 될 때마다 매번 무엇이 바뀌는지 걱정할 필요가 없다.그러나 React 내부에서 어떤 일이 일어나고 있는지 평확하게 볼 수가 없다. 

---

## 동기

React를 사용하면 'render() 함수는 React 엘리먼트 트리를 만드는 것이다.'라고 생각이 들 수 있다. state나 props가 갱신되면 render() 함수는 새로운 React 엘리먼트 트리를 반환할 것이다. 이때 React는 방금 만들어진 트리에 맞게 가장 효과적인 UI를 갱신하는 방법을 알아낼 필요가 있다.  
  
---

## 비교 알고리즘 (Diffing Algorithm)

두 개의 트리를 비교할 때, React는 두 엘리먼트의 루트(root) 엘리먼트부터 비교한다. 이후의 동작은 루트 엘리먼트의 타입에 따라 달라진다.

### 엘리먼트의 타입이 다른 경우  

두 루트 엘리먼트의 타입이 다르면, React는 이전 트리를 버리고 완전히 새로운 트리를 구축한다. \<a> 에서 \<img>로 , \<Article> 에서 \<Comment>로, 혹은 \<Button> 에서 \<div>로 바뀌는 것 모두 트리 전체를 재구축하는 경우이다.  
  
**트리를 버릴 때 이전 DOM 노드들은 모두 파괴된다.** 
- 컴포넌트 인스턴스는 componentWillUnmount() 실행된다.
- 새로운 트리가 만들어질 때, 새로운 DOM 노드들이 DOM에 삽입된다.  
  
  
그에 따라 컴포넌트 인스턴스는 
- UNSAFE_componentWillMount()가 실행되고
- componentDidMount()가 이어서 실행된다.  
- 이전 트리와 연관된 모든 state는 사라진다.  
  
루트 엘리먼트 아래의 모든 컴포넌트도 언마운트되고 그 state도 사라진다.

``` js
<div>
  <Counter />
</div>

<span>
  <Counter />
<span>
```

이전 Counter는 사라지고, 새로 다시 마운트가 될 것.

> #### 주의
> 아래 메서드들은 레거시이며 새로 작성하는 코드에서는 피해야 한다.
> - UNSAFE_componentWillMount()

### DOM 엘리먼트의 타입이 같은 경우

같은 타입의 두 React DOM 엘리먼트를 비교할 때, React는 두 엘리먼트의 속성을 확인하여, 동일한 내역은 유지하고 변경된 속성들만 갱신한다. 

``` js
<div className="before" title="stuff" />

<div className="after" title="stuff" />
```

이 두 엘리먼트를 비교하면, React는 현재 DOM 노드 상에 classNAme만 수정한다.  
  
style이 갱신될 때, React는 또한 변경된 속성만 갱신한다.  

[예시]  

``` js
<div style={{color: 'red', fontWeight: 'bold'}} />

<div style={{color: 'green', fontWeight: 'bold'}} />
```

위 두 엘리먼트 사이에서 변경될 때, React는 fontWeight는 수정하지 않고 color 속성만 수정한다.  
  
DOM 노드의 처리가 끝나면, React는 이어서 해당 노드의 자식들을 재귀적으로 처리한다.

### 같은 타입의 컴포넌트 엘리먼트

컴포넌트가 갱신되면 인스턴스는 동일하게 유지되어 렌더링 간 state가 유지된다. React가 새로운 엘리먼트의 내용을 반영하기 위해 현재 컴포넌트 인스턴스의 props를 갱신해야 한다.  
  
다음으로 render() 메서드가 호출되고 비교 알고리즘이 이전 결과와 새로운 결과를 재귀적으로 처리한다.

---

## 자식에 대한 재귀적 처리

DOM 노드의 자식들을 재귀적으로 처리할 때, React는 기본적으로 동시에 두 리스트를 순회하고 차이점이 있으면 변경을 생성한다.  
  
예를 들어, 자식 끝에 엘리먼트를 추가하면, 두 트리 사이의 변경은 잘 작동할 것이다.

``` js
<ul>
  <li>first</li>
  <li>second</li>
</ul>

<ul>
  <li>first</li>
  <li>second</li>
  <li>third</li>
</ul>
```

React는 두 트리에서 \<li>first\<li>가 일치하는 것을 확인하고, \<li>second\<li>가 일치하는 것을 확인합니다. 그리고 마지막으로 \<li>third\<li>를 트리에 추가합니다.  
  
하지만 위와 같이 단순하게 구현하면 리스트의 맨 앞에 엘리먼트를 추가하는 경우 성능이 좋지 않다.  
  
아래의 두 트리 변환은 성능이 좋지 않다.

``` js
<ul>
  <li>Duke</li>
  <li>Villanova</li>
</ul>

<ul>
  <li>Connecticut</li>
  <li>Duke</li>
  <li>Villanova</li>
</ul>
```

React는 \<li>Duck\</li>와 \<li>Villanova\</li> 종속 트리를 그대로 유지하는 대신 모든 자식을 변경한다. 이러한 비효율은 문제가 될 수 잇다.

### Keys

이러한 문제를 해결하기 위해, React는 key 속성을 지원한다. 자식들이 key를 가지고 있다면, React는 key를 통해 기존 트리와 이후 트리의 자식들이 일치하는지 확인한다.  
  
예를 들어, 위 비효율적인 예시에 key를 추가하여 트리의 변환 작업이 효율적으로 수행되도록 수정할 수 있다.

``` js
<ul>
  <li key="2015">Duke</li>
  <li key="2016">Villanova</li>
</ul>

<ul>
  <li key="2014">Connecticut</li>
  <li key="2015">Duke</li>
  <li key="2016">Villanova</li>
</ul>
```

이제 React는 '2014' key를 가진 엘리컨트를 새로 추가되었고, '2015'와 '2016' key를 가진 엘리먼트는 그저 이동만 하면 되는 것을 알 수 있다.  
  
실제로, key로 사용할 값을 정하는 것은 어렵지 않다. 그리려고 하는 엘리먼트는 일반적으로 식별자를 가지고 있을 것이고, 그대로 해당 데이터를 key로 사용할 수 있다.

``` js
<li key={item.id}>{item.name}</li>
```

만약 이러한 상황에 해당하지 않는다면, 데이터 구조에 ID라는 속성을 추가해주거나 데이터 일부에 해시를 적용해서 key를 생성할 수 있다. 해당 key는 오로지 형제 사이에서만 유일하면 되고, 전역에서 유일할 필요는 없다.  
  
배열 인덱스의 경우 재별이 되는 경우 비효율적으로 동작할 것이다.  
  
인덱스를 key로 사용 중 배열이 재배열되면 컴포넌트의 state와 관련된 문제가 발생할 수 있다.

---

## 고려 사항

재조정 알고리즘은 구현상의 세부사항이다.  
React는 항상 전체 앱을 재렌더링할 수도 있지만, 최종적으로 출력되는 결과는 항상 같을 것이다. 
> 재렌더링은 모든 컴포넌트의 render를 호출하는 것이지 React가 언마운트시키고 다시 마운트 하는 것이 아니다.
  
**React는 휴리스틱에 의존하고 있기 때문에, 휴리스틱이 기반하고 있는 가정에 부합하지 않는 경우 성능이 나빠질 수 있다.**

- 알고리즘은 다른 컴포넌트 타입을 갖는 종속 트리들의 일치 여부를 확안하지 않는다. 만약 매우 비슷한 결과물을 출력하는 두 컴포넌트를 교체하고 있다면, 그 둘을 같은 타입으로 만드는 것이 나을 수 있다.
- key는 반드시 변하지 않고, 예상 가능하며 유일해야 한다. 변하는 key(Math.random()으로 생성된 값 등)를 사용하면 많은 컴포넌트 인스턴스와 DOM노드를 불필요하게 재생성하여 성능이 나빠지거나 자식 컴포넌트의 state가 유실될 수 있다.