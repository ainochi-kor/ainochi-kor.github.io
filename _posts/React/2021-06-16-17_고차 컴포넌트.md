---
layout: post
author: ainochi-kor
title: React/17. HOC(Higher Order Component(고차 컴포넌트))
---

고차 컴포넌트(HOC, Higher Order Component)는 컴포넌트 로직을 재사용하기 위한 React 고급 기술이며, **컴포넌트를 가져와 새 컴포넌트를 반환하는 함수.**

``` js
const EnhancedComponent = higherOrderComponent(WrappedComponent);
```

컴포넌트는 props를 UI로 변환하는 반면에, 고차 컴포넌트는 컴포넌트를 새로운 컴포넌트로 변환한다.  
  
고차 컴포넌트(HOC)는 Redux의 connect와 Relay의 createFragmentContainer와 같은 서드 파티 리액트 라이브러리에서 흔하게 볼 수 있다.

---

## 횡단 관심사(Cross-Cutting Concerns)에 고차 컴포넌트 사용하기

> #### 주의
> 이전에는 횡단 관심사 문제를 제어하기 위해 mixin 사용을 권장하였지만 mixin을 사용하는 것은 더 많은 문제를 일으킨다. [참고](https://ko.reactjs.org/blog/2016/07/13/mixins-considered-harmful.html)

컴포넌트는 React에서 코드 재사용의 기본 단위이다. 그러나 어떤 패턴은 기존 컴포넌트에 잘 적용되지 않을 수 있다.

[외부로부터 데이터를 구독하여 댓글 목록을 렌더링하는 CommentList 컴포넌트 예시]

``` js
class CommentList extends React.Component {
  constructor(props) {
    super(props);
    this.handleChange = this.handleChange.bind(this);
    this.state = {
      // "DatatSource"는 글로벌 데이터 소스이다.
      comments: DataSource.getCommnets()
    };
  }

  componentDidMount() {
    // 변화감지를 위해 리서너를 추가.
    DataSource.addChangeListener(this.handleChange);
  }

  componentWillUnmount() {
    // 리스너 제거
    DataSource.removeChangeListener(this.handleChange);
  }

  handleChange() {
    // 데이터 소스가 변경될 때마다 comments를 업데이트 합니다.
    this.setState({
      comments: DataSource.getComments()
    });
  }
  render() {
    return (
      <div>
        {this.state.comments.map((comment) => (
          <Comment comment={comment} key={comment.id} />
        ))}
      </div>
    )
  }
}
```

그리고 블로그 포스트를 구독하기 위해 위와 비슷한 패턴으로 컴포넌트 작성

``` js
class BlogPost extends React.Component {
  constructor(props) {
    super(props);
    this.handleChange = this.handleChange.bind(this);
    this.state = {
      blogPost: DataSource.getBlogPost(props.id)
    };
  }

  componentDidMount() {
    DataSource.addChangeListener(this.handleChange);
  }

  componentWillUnmount() {
    DataSource.removeChangeListener(this.handleChange);
  }

  handleChange() {
    this.setState({
      blogPost: DataSource.getBlogPost(this.props.id)
    });
  }

  render() {
    return <TextBlock text={this.state.blogPost} />;
  }
}
```

CommentList와 BlogPost 컴포넌트는 동일하지 않다. 두 컴포넌트는 DataSource에서 서로 다른 메서드를 호출하여 다른 렌더링 결과를 보여준다. 하지만 대부분의 구현체는 동일하다

- 컴포넌트가 마운트되면, change 리스터를 DataSource에 추가한다.
- 리스너 안에서, 데이터 소스가 변경되면 setState를 호출한다.
- 컴포넌트가 마운트 해제되면 change 리스너를 제거합니다.

규모가 큰 애플리케이션에서 DataSource를 구독하고, setState를 호출하는 동일한 패턴이 반복적으로 발생한다고 가정해보자. 그렇게 된다면 이 로직을 한 곳에서 정의하고 많은 컴포넌트에서 로직을 공유할 수 있게 하는 추상화가 필요하게 된다. 이러한 경우 고차 컴포넌트를 사용하면 좋다.  
  
DataSource를 구독하는 CommentList나 BlogPost 같은 컴포넌트를 생성하는 함수를 작성 가능하다. 구독한 데이터를 prop으로 전달받는 자식 컴포넌트를 파라미터 중 하나로 받는 함수를 만든다.

``` js
// withSubScription : 구독한 데이터를 prop으로 전달받는 자식 컴포넌트를 파라미터 중 하나로 받는 함수
const CommentListWithSubscription = withSubscription(
  CommentList,
  (DataSource) => DataSource.getComments()
);

const BlogPostWithSubscription = withSubScription(
  BlogPost,
  (DataSource, props) => DataSource.getBlogPost(props.id)
)
```

첫 번째 파라미터는 래핑된 컴포넌트이다. 두 번째 파라미터에는 DataSource와 현재 props를 가지고 컴포넌트에서 관심 있는 데이터를 검색한다.